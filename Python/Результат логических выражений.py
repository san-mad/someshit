'''


#      Составные выражения

Если соединить логические выражения между собой, можно получать довольно интересные способы решения задач с кодом.

Допустим, нам нужно реализовать код, в котором в переменную записывается:

    Строка yes, если число четное
    Строка no, если нечетное

Это можно сделать, если использовать знания, полученные выше:

#       число четное
result = 10 % 2 == 0 and 'yes' or 'no' # 'yes'
# или сразу печатаем на экран
print(10 % 2 == 0 and 'yes' or 'no') # => 'yes'
# число нечетное
print(11 % 2 == 0 and 'yes' or 'no') # => 'no'

Эти выражения работают согласно порядку и приоритетам. 
Приоритет присваивания самый низкий, поэтому оно происходит в конце.
Приоритет сравнения == выше, чем приоритет логических операторов and и or, 
поэтому сравнение происходит раньше. Дальше код выполняется слева направо, 
так как приоритет and выше, чем приоритет or. Рассмотрим по шагам:
    # Для четного
# 1 шаг
10 % 2 == 0 # True
# 2 шаг
True and 'yes' # Результат — 'yes'
# Проверка на or выполняется, но правая часть не исполняется, так как сразу возвращается 'yes'

#        Для нечетного
# 1 шаг
11 % 2 == 0 # False
# 2 шаг
False and 'yes' # Результат — ложь, проверяем дальше
# 3 шаг
False or 'no' # Выбирается и возвращается 'no'
 
#       Такую же схему можно использовать с любым выражением в начале:

print(somefunc() and 'yes' or 'no')





#       Двойное отрицание

Напомним, как выглядит операция отрицания:

answer = True
print(not answer)  # => False

При двойном отрицании итоговое значение равно начальному:

answer = True
print(not not answer)  # => True

Оператор not всегда возвращает булевое значение, независимо от типа переданного аргумента, а не заменяет значение на противоположное. Поэтому двойное отрицание тоже вернет булевое True/False.

answer = 'python'
print(not answer) # => False
print(not not answer) # => True





#          Ошибка выбора

Представьте, что нам нужно проверить — значение равно одному или другому. Например, переменная value должна содержать одно из двух значений: first или second. Начинающие разработчики иногда записывают это выражение так:

value == ('first' or 'second')

Однако такой код приведет к неверному результату. Необходимо вспомнить приоритет выполнения операций. Первым делом вычисляется все, что указано в скобках — 'first' or 'second'. Если выполнить этот код в Replit, то вывод будет таким:

python
Python 3.8.2 (default, Apr 12 2020, 15:53:37)
>>> 'first' or 'second'
'first'
>>>

Теперь заменим исходное выражение на частично вычисленное:

value == 'first'

Совсем не то, что мы ожидали. А теперь вернемся к началу и напишем проверку правильно:

# Скобки ставить не обязательно,
# потому что приоритет == выше чем приоритет or
value == 'first' or value == 'second'


'''
 
def string_or_not(value):
    return isinstance(value, str) and "yes" or "no"
print(string_or_not('popie'))  # => 'yes'
#Функция isinstance() проверяет, 
# является ли объект экземпляром указанного класса или кортежа классов. 
# В нашем случае она используется для проверки, является ли переданное значение строкой (str). 
# Если да, возвращается 'yes', иначе - 'no'.
